<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>She is Art</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            animation: fadeInDown 1s ease-out;
        }

        .header h1 {
            font-size: 3.5rem;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            margin-bottom: 10px;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .header p {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.9);
            font-style: italic;
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            animation: fadeInUp 1s ease-out;
        }

        .upload-area {
            border: 3px dashed #764ba2;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .upload-icon {
            font-size: 4rem;
            color: #764ba2;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 1.3rem;
            color: #666;
            margin-bottom: 15px;
        }

        .upload-subtext {
            color: #999;
            font-size: 0.9rem;
        }

        #fileInput {
            display: none;
        }

        .style-selector {
            margin: 30px 0;
        }

        .style-selector h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.4rem;
        }

        .style-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .style-option {
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            background: white;
        }

        .style-option:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .style-option.selected {
            border-color: #764ba2;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .generate-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 20px auto;
            display: block;
            font-family: inherit;
            letter-spacing: 1px;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .generate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-section {
            display: none;
            margin-top: 40px;
        }

        .result-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            animation: fadeInUp 0.8s ease-out;
        }

        .result-images {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .image-container {
            text-align: center;
        }

        .image-container h4 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.2rem;
        }

        .image-container img {
            max-width: 100%;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease;
        }

        .image-container img:hover {
            transform: scale(1.02);
        }

        .romantic-quote {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 15px;
            border-left: 4px solid #764ba2;
        }

        .romantic-quote p {
            font-size: 1.3rem;
            font-style: italic;
            color: #555;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .romantic-quote .author {
            font-size: 0.9rem;
            color: #888;
            font-style: normal;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #764ba2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .download-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.3s ease;
        }

        .download-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.5rem;
            }

            .result-images {
                grid-template-columns: 1fr;
            }

            .upload-section,
            .result-card {
                padding: 20px;
            }

            .romantic-quote p {
                font-size: 1.1rem;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>She is Art</h1>
            <p>"Transform moments into masterpieces"</p>
        </div>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ðŸŽ¨</div>
                <div class="upload-text">Drop her photo here or click to upload</div>
                <div class="upload-subtext">Support for JPG, PNG files</div>
                <input type="file" id="fileInput" accept="image/*">
            </div>

            <div class="style-selector">
                <h3>Choose Your Artistic Style</h3>
                <div
                    style="margin-bottom: 15px; padding: 10px; background: #f0f8ff; border-radius: 8px; font-size: 0.9rem; color: #555;">
                    âœ¨ <strong>AI-Powered:</strong> Add your API keys at the top of the code to use professional AI
                    services:<br>
                    â€¢ <strong>Stability AI:</strong> Best quality - Get free credits at platform.stability.ai<br>
                    â€¢ <strong>Replicate:</strong> Many models - Free tier at replicate.com<br>
                    â€¢ <strong>DeepAI:</strong> Fast processing - Free tier at deepai.org<br>
                    â€¢ <strong>Hugging Face:</strong> Open source - Free at huggingface.co<br>
                    Falls back to local processing if no API keys provided.
                </div>
                <div class="style-grid">
                    <div class="style-option selected" data-style="vangogh">
                        <strong>Van Gogh</strong><br>
                        <small>Swirling dreams</small>
                    </div>
                    <div class="style-option" data-style="watercolor">
                        <strong>Watercolor</strong><br>
                        <small>Soft whispers</small>
                    </div>
                    <div class="style-option" data-style="oil">
                        <strong>Oil Painting</strong><br>
                        <small>Rich textures</small>
                    </div>
                    <div class="style-option" data-style="sketch">
                        <strong>Charcoal Sketch</strong><br>
                        <small>Raw emotion</small>
                    </div>
                    <div class="style-option" data-style="anime">
                        <strong>Anime</strong><br>
                        <small>Ethereal beauty</small>
                    </div>
                    <div class="style-option" data-style="impressionist">
                        <strong>Impressionist</strong><br>
                        <small>Light & shadow</small>
                    </div>
                </div>
            </div>

            <button class="generate-btn" id="generateBtn" disabled>Create Art âœ¨</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Creating your masterpiece...</p>
        </div>

        <div class="results-section" id="resultsSection">
            <div class="result-card">
                <div class="result-images">
                    <div class="image-container">
                        <h4>Original</h4>
                        <img id="originalImage" alt="Original">
                        <br>
                        <button class="download-btn" onclick="downloadImage('original')">Download Original</button>
                    </div>
                    <div class="image-container">
                        <h4 id="styleTitle">Artistic Vision</h4>
                        <img id="styledImage" alt="Styled">
                        <br>
                        <button class="download-btn" onclick="downloadImage('styled')">Download Art</button>
                    </div>
                </div>

                <div class="romantic-quote">
                    <p id="romanticText"></p>
                    <div class="author">- From the heart</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedFile = null;
        let selectedStyle = 'vangogh';

        const romanticQuotes = {
            vangogh: [
                "This is how I see you on the days you laugh without trying - a masterpiece painted in golden swirls of joy.",
                "In your eyes, I find the same stars Van Gogh painted in his wildest dreams.",
                "You are the sunflower that turns my world toward light, painted in brushstrokes of forever.",
                "Like starry nights and cypress trees, you make the ordinary world extraordinary."
            ],
            watercolor: [
                "You are watercolor on my soul - soft, flowing, and impossibly beautiful.",
                "This is how love looks when it bleeds gently into every corner of my heart.",
                "In the gentle blur of watercolor, I see how you've softened all my sharp edges.",
                "You paint my world in pastels and whispered promises."
            ],
            oil: [
                "This is how the masters would have painted you - with layers of devotion and centuries of technique.",
                "In oil and canvas, I capture what my heart has always known - you are living art.",
                "Rich textures and deeper colors could never match the complexity of your beauty.",
                "Like a painting that grows more beautiful with age, so does my love for you."
            ],
            sketch: [
                "In simple lines and shadows, I find the complexity of loving you.",
                "This is the raw truth of how I see you - unfiltered, honest, breathtaking.",
                "Sometimes the most beautiful art is the simplest - like the way you exist in my world.",
                "In charcoal and dreams, I sketch the outline of forever with you."
            ],
            anime: [
                "In every universe, in every story, you would still be the protagonist of my heart.",
                "This is how you look in my dreams - ethereal, magical, and perfectly impossible to forget.",
                "You have the kind of beauty that belongs in fairy tales and cherry blossom promises.",
                "Like an anime heroine, you make the impossible seem inevitable in my heart."
            ],
            impressionist: [
                "You are light dancing on water, captured in brushstrokes of pure emotion.",
                "This is how you look in golden hour - luminous, soft, absolutely radiant.",
                "Like morning light through autumn leaves, you illuminate everything you touch.",
                "In dappled sunlight and gentle shadows, I see all the ways I love you."
            ]
        };

        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const generateBtn = document.getElementById('generateBtn');

        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        function handleFile(file) {
            if (file.type.startsWith('image/')) {
                selectedFile = file;
                generateBtn.disabled = false;

                uploadArea.innerHTML = `
                    <div class="upload-icon">âœ…</div>
                    <div class="upload-text">Photo selected: ${file.name}</div>
                    <div class="upload-subtext">Click to choose a different photo</div>
                `;
            }
        }

        // Style selection
        document.querySelectorAll('.style-option').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.style-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedStyle = option.dataset.style;
            });
        });

        // API Keys - Replace with your actual keys
        const API_KEYS = {
            huggingface: 'hf_your_token_here', // Get from huggingface.co/settings/tokens
            replicate: 'r8_your_token_here',   // Get from replicate.com/account
            stability: 'sk_your_key_here',     // Get from platform.stability.ai/account/keys
            deepai: 'your_key_here'            // Get from deepai.org/dashboard
        };

        // Working AI Service Configuration
        const AI_SERVICES = {
            huggingface: {
                name: 'Hugging Face',
                models: {
                    vangogh: 'Lykon/DreamShaper',
                    watercolor: 'runwayml/stable-diffusion-v1-5',
                    oil: 'stabilityai/stable-diffusion-2-1',
                    sketch: 'nitrosocke/Ghibli-Diffusion',
                    anime: 'Linaqruf/anything-v3.0',
                    impressionist: 'runwayml/stable-diffusion-v1-5'
                }
            },
            replicate: {
                name: 'Replicate',
                models: {
                    vangogh: 'tencentarc/gfpgan:9283608cc6b7be6b65a8e44983db012355fde4132009bf99d976b2f0896856a3',
                    watercolor: 'stability-ai/stable-diffusion:db21e45d3f7023abc2a46ee38a23973f6dce16bb082a930b0c49861f96d1e5bf',
                    oil: 'lucataco/realistic-vision-v5:ac732df83cea7fff18b63fb98bc658a08e2a69d16fbc7c9c2d12b01b49c96822',
                    sketch: 'jagilley/controlnet-scribble:435061a1b5a4c1e26740464bf786efdfa9cb3a3ac488595a2de23e143fdb0117',
                    anime: 'cjwbw/waifu-diffusion:25d2f75ecda0c0bed34c806b7b70319a53a1bccad3ade1a7496524f013f48983',
                    impressionist: 'stability-ai/stable-diffusion:db21e45d3f7023abc2a46ee38a23973f6dce16bb082a930b0c49861f96d1e5bf'
                }
            }
        };

        // Generate art with AI fallback
        generateBtn.addEventListener('click', generateArt);

        async function generateArt() {
            if (!selectedFile) return;

            document.getElementById('loading').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'none';

            const reader = new FileReader();
            reader.onload = async function (e) {
                const originalImageData = e.target.result;

                try {
                    // Try AI services first
                    let styledImageData = await tryAIStyleTransfer(selectedFile, selectedStyle);

                    if (!styledImageData) {
                        // Fallback to local processing
                        console.log('AI services unavailable, using local processing...');
                        styledImageData = await applyLocalArtisticStyle(originalImageData, selectedStyle);
                    }

                    displayResults(originalImageData, styledImageData);

                } catch (error) {
                    console.error('Error generating art:', error);
                    // Fallback to local processing
                    const styledImageData = await applyLocalArtisticStyle(originalImageData, selectedStyle);
                    displayResults(originalImageData, styledImageData);
                }
            };
            reader.readAsDataURL(selectedFile);
        }

        // Try multiple AI services for style transfer
        async function tryAIStyleTransfer(imageFile, style) {
            const services = [
                () => tryHuggingFaceAPI(imageFile, style),
                () => tryReplicateAPI(imageFile, style),
                () => tryStabilityAPI(imageFile, style),
                () => tryDeepAIAPI(imageFile, style)
            ];

            for (const service of services) {
                try {
                    const result = await service();
                    if (result) return result;
                } catch (error) {
                    console.log('Service failed, trying next...', error.message);
                    continue;
                }
            }

            return null; // All services failed
        }

        // Fixed Hugging Face API integration
        async function tryHuggingFaceAPI(imageFile, style) {
            if (API_KEYS.huggingface === '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') {
                throw new Error('Please add your Hugging Face API key');
            }

            const modelId = AI_SERVICES.huggingface.models[style];

            // Convert image to base64
            const base64Image = await fileToBase64(imageFile);
            const imageData = base64Image.split(',')[1]; // Remove data:image/jpeg;base64, prefix

            const response = await fetch(`https://api-inference.huggingface.co/models/${modelId}`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${API_KEYS.huggingface}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    inputs: getStylePrompt(style),
                    parameters: {
                        num_inference_steps: 20,
                        guidance_scale: 7.5,
                        width: 512,
                        height: 512
                    },
                    options: {
                        wait_for_model: true
                    }
                })
            });

            if (response.ok) {
                const blob = await response.blob();
                return URL.createObjectURL(blob);
            } else {
                const error = await response.text();
                console.error('Hugging Face error:', error);
                throw new Error(`Hugging Face API failed: ${error}`);
            }
        }

        // Fixed Replicate API integration
        async function tryReplicateAPI(imageFile, style) {
            if (API_KEYS.replicate === 'r8_JqdwvzfhBYLO1pau2kUjh4Cte3pqilW38mSLT') {
                throw new Error('Please add your Replicate API key');
            }

            const base64Image = await fileToBase64(imageFile);
            const modelVersion = AI_SERVICES.replicate.models[style];

            // Create prediction
            const response = await fetch('https://api.replicate.com/v1/predictions', {
                method: 'POST',
                headers: {
                    'Authorization': `Token ${API_KEYS.replicate}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    version: modelVersion,
                    input: {
                        image: base64Image,
                        prompt: getStylePrompt(style),
                        num_inference_steps: 20,
                        guidance_scale: 7.5,
                        scheduler: "K_EULER"
                    }
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`Replicate API failed: ${error}`);
            }

            const prediction = await response.json();

            // Poll for completion
            return await pollReplicateResult(prediction.id);
        }

        // Fixed polling function
        async function pollReplicateResult(predictionId) {
            let attempts = 0;
            const maxAttempts = 60; // 2 minutes max

            while (attempts < maxAttempts) {
                const response = await fetch(`https://api.replicate.com/v1/predictions/${predictionId}`, {
                    headers: {
                        'Authorization': `Token ${API_KEYS.replicate}`,
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to check prediction status');
                }

                const result = await response.json();

                if (result.status === 'succeeded') {
                    return Array.isArray(result.output) ? result.output[0] : result.output;
                } else if (result.status === 'failed') {
                    throw new Error(`Replicate processing failed: ${result.error}`);
                }

                await new Promise(resolve => setTimeout(resolve, 2000));
                attempts++;
            }

            throw new Error('Replicate timeout - processing took too long');
        }

        // Fixed Stability AI integration
        async function tryStabilityAPI(imageFile, style) {
            if (API_KEYS.stability === 'sk-wFNzPFmNy1pfd7eHxiMHwtzBVws99CDHZV2GLHYVJDYGNJZI') {
                throw new Error('Please add your Stability AI API key');
            }

            const formData = new FormData();
            formData.append('init_image', imageFile);
            formData.append('init_image_mode', 'IMAGE_STRENGTH');
            formData.append('image_strength', '0.4');
            formData.append('text_prompts[0][text]', getStylePrompt(style));
            formData.append('text_prompts[0][weight]', '1');
            formData.append('cfg_scale', '7');
            formData.append('samples', '1');
            formData.append('steps', '30');

            const response = await fetch('https://api.stability.ai/v1/generation/stable-diffusion-v1-6/image-to-image', {
                method: 'POST',
                body: formData,
                headers: {
                    'Authorization': `Bearer ${API_KEYS.stability}`,
                    'Accept': 'application/json'
                }
            });

            if (!response.ok) {
                const error = await response.text();
                console.error('Stability AI error:', error);
                throw new Error(`Stability AI failed: ${error}`);
            }

            const result = await response.json();

            if (result.artifacts && result.artifacts[0]) {
                return `data:image/png;base64,${result.artifacts[0].base64}`;
            }

            throw new Error('No image returned from Stability AI');
        }

        // Fixed DeepAI integration
        async function tryDeepAIAPI(imageFile, style) {
            if (API_KEYS.deepai === '17622fed-9ab3-4c23-83c6-b2f5cdefb659') {
                throw new Error('Please add your DeepAI API key');
            }

            const formData = new FormData();
            formData.append('image', imageFile);

            // Use different endpoints for different styles
            let endpoint = 'neural-style';
            if (style === 'sketch') endpoint = 'pencil-sketch';
            if (style === 'anime') endpoint = 'toonify';
            if (style === 'watercolor') endpoint = 'watercolor';

            const response = await fetch(`https://api.deepai.org/api/${endpoint}`, {
                method: 'POST',
                body: formData,
                headers: {
                    'Api-Key': API_KEYS.deepai
                }
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`DeepAI failed: ${error}`);
            }

            const result = await response.json();

            if (result.output_url) {
                // Convert URL to data URI for consistency
                const imageResponse = await fetch(result.output_url);
                const blob = await imageResponse.blob();
                return URL.createObjectURL(blob);
            }

            throw new Error('No output URL from DeepAI');
        }

        // Generate style-specific prompts for AI models
        function getStylePrompt(style, subject = "a beautiful portrait") {
            const prompts = {
                vangogh: `${subject}, painted in the style of Vincent van Gogh, bold swirling brushstrokes, expressive post-impressionism, vivid contrasting colors, emotional intensity, textured canvas, starry night mood`,

                watercolor: `${subject}, delicate watercolor painting, soft flowing pigments, pastel tones, light and dreamy atmosphere, transparent layers, brush textures on textured paper, artistic and serene`,

                oil: `${subject}, classical oil painting, rich textures and depth, dramatic chiaroscuro lighting, renaissance or baroque style, realistic proportions, museum-quality composition, thick impasto brushwork`,

                sketch: `${subject}, pencil or charcoal sketch, monochrome line art, intricate cross-hatching, precise anatomy and shading, lifelike and detailed illustration, drawn on textured paper`,

                anime: `${subject}, high-quality anime style illustration, vivid cel shading, expressive eyes, clean digital lines, colorful and dynamic, inspired by Japanese manga, cute and energetic composition, studio-quality render`,

                impressionist: `${subject}, impressionist artwork, inspired by Claude Monet, soft and atmospheric, natural lighting, visible brushstrokes, outdoor scenery, warm and cool color harmony, painted en plein air`
            };

            return prompts[style.toLowerCase()] || prompts.vangogh;
        }


        // Helper function to convert file to base64
        async function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        // Helper function to resize image if too large
        async function resizeImageIfNeeded(file, maxSize = 1024) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = function () {
                    let { width, height } = img;

                    // Resize if image is too large
                    if (Math.max(width, height) > maxSize) {
                        const ratio = maxSize / Math.max(width, height);
                        width *= ratio;
                        height *= ratio;
                    }

                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);

                    canvas.toBlob(resolve, 'image/jpeg', 0.8);
                };

                img.src = URL.createObjectURL(file);
            });
        }

        // Enhanced try AI services with better error handling
        async function tryAIStyleTransfer(imageFile, style) {
            // Resize image if too large for APIs
            const resizedFile = await resizeImageIfNeeded(imageFile, 1024);

            const services = [
                { name: 'Stability AI', fn: () => tryStabilityAPI(resizedFile, style) },
                { name: 'Replicate', fn: () => tryReplicateAPI(resizedFile, style) },
                { name: 'DeepAI', fn: () => tryDeepAIAPI(resizedFile, style) },
                { name: 'Hugging Face', fn: () => tryHuggingFaceAPI(resizedFile, style) }
            ];

            for (const service of services) {
                try {
                    console.log(`Trying ${service.name}...`);
                    const result = await service.fn();
                    if (result) {
                        console.log(`âœ… ${service.name} succeeded!`);
                        return result;
                    }
                } catch (error) {
                    console.log(`âŒ ${service.name} failed:`, error.message);
                    continue;
                }
            }

            console.log('All AI services failed, falling back to local processing');
            return null;
        }

        // Rename original function to local processing
        async function applyLocalArtisticStyle(imageData, style) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = function () {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    // Apply the selected style
                    switch (style) {
                        case 'vangogh':
                            applyVanGoghEffect(ctx, canvas.width, canvas.height);
                            break;
                        case 'watercolor':
                            applyWatercolorEffect(ctx, canvas.width, canvas.height);
                            break;
                        case 'oil':
                            applyOilPaintingEffect(ctx, canvas.width, canvas.height);
                            break;
                        case 'sketch':
                            applySketchEffect(ctx, canvas.width, canvas.height);
                            break;
                        case 'anime':
                            applyAnimeEffect(ctx, canvas.width, canvas.height);
                            break;
                        case 'impressionist':
                            applyImpressionistEffect(ctx, canvas.width, canvas.height);
                            break;
                    }

                    resolve(canvas.toDataURL());
                };

                img.src = imageData;
            });
        }

        // Simple but effective artistic style functions

        // Utility functions
        function rand(min, max) { return min + Math.random() * (max - min); }
        function rgbToHSL(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h = 0, s = 0, l = (max + min) / 2;
            if (max !== min) {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s * 100, l * 100];
        }
        function applyVanGoghEffect(ctx, width, height) {
            // 1) READ PIXELS & APPLY PALETTE CURVES
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                // Extract original channels
                let [r, g, b] = [data[i], data[i + 1], data[i + 2]];

                // Apply gentle Sâ€‘curve for contrast
                r = 255 * (Math.pow(r / 255, 0.8));
                g = 255 * (Math.pow(g / 255, 0.9));
                b = 255 * (Math.pow(b / 255, 1.1));

                // Boost midtones toward Van Goghâ€™s palette
                data[i] = Math.min(255, r * 1.3 + 10);       // reds/yellows up
                data[i + 1] = Math.min(255, g * 1.1 + 5);        // greens moderate
                data[i + 2] = Math.min(255, b * 0.8 - 5);        // blues slightly darker
            }
            ctx.putImageData(imageData, 0, 0);

            // Prepare for strokes
            ctx.globalAlpha = 0.4;
            ctx.lineCap = 'round';

            // 2) SHORT, CURVED BRUSH STROKES
            for (let s = 0; s < 300; s++) {
                const x0 = Math.random() * width;
                const y0 = Math.random() * height;
                const dx = (Math.random() - 0.5) * 40;
                const dy = (Math.random() - 0.5) * 40;

                // Sample underlying color for stroke hue
                const px = ctx.getImageData(x0, y0, 1, 1).data;
                let hue = rgbToHSL(px[0], px[1], px[2])[0] + (Math.random() * 20 - 10);

                ctx.strokeStyle = `hsl(${hue}, 60%, ${50 + Math.random() * 10}%)`;
                ctx.lineWidth = 1 + Math.random() * 3;

                // Draw a small bezier curve
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.bezierCurveTo(
                    x0 + dx * 0.5 + rand(-20, 20),
                    y0 + dy * 0.5 + rand(-20, 20),
                    x0 + dx * 0.5 + rand(-20, 20),
                    y0 + dy * 0.5 + rand(-20, 20),
                    x0 + dx,
                    y0 + dy
                );
                ctx.stroke();
            }

            // 3) BIG SWIRLS
            ctx.globalAlpha = 0.25;
            for (let w = 0; w < 5; w++) {
                const cx = Math.random() * width;
                const cy = Math.random() * height;
                const baseRadius = 30 + Math.random() * 100;
                const turns = 3 + Math.random() * 2;

                for (let theta = 0; theta < turns * Math.PI * 2; theta += 0.2) {
                    const r = baseRadius * (theta / (turns * 2 * Math.PI));
                    const x = cx + r * Math.cos(theta);
                    const y = cy + r * Math.sin(theta);

                    ctx.strokeStyle = `hsla(${60 + w * 20}, 50%, 70%, 0.2)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(
                        cx + (r - 4) * Math.cos(theta - 0.1),
                        cy + (r - 4) * Math.sin(theta - 0.1)
                    );
                    ctx.lineTo(x, y);
                    ctx.stroke();
                }
            }

            // 4) CANVASâ€‘GRAIN NOISE
            ctx.globalAlpha = 0.1;
            for (let i = 0; i < width * height * 0.05; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.05})`;
                ctx.fillRect(
                    Math.random() * width,
                    Math.random() * height,
                    1, 1
                );
            }

            // RESET
            ctx.globalAlpha = 1;
            ctx.filter = 'none';
        }

        // Utility: random in [â€“max, +max]
        function rand(min, max) {
            return Math.random() * (max - min) + min;
        }

        // Utility: convert RGB to HSL (returns [h, s%, l%])
        function rgbToHSL(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
                    case g: h = ((b - r) / d + 2); break;
                    case b: h = ((r - g) / d + 4); break;
                }
                h /= 6;
            }
            return [Math.round(360 * h), Math.round(100 * s), Math.round(100 * l)];
        }

        // 1) Watercolor Effect
        function applyWatercolorEffect(ctx, width, height) {
            // White-paper base
            ctx.save();
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, width, height);
            ctx.globalAlpha = 0.9;
            ctx.drawImage(ctx.canvas, 0, 0);
            ctx.globalAlpha = 1;
            ctx.restore();

            // Multi-scale blur & color boost
            ctx.save();
            ctx.filter = 'blur(1px) saturate(1.1) brightness(1.05)';
            ctx.drawImage(ctx.canvas, 0, 0);
            ctx.filter = 'blur(3px)';
            ctx.drawImage(ctx.canvas, 0, 0);
            ctx.filter = 'none';
            ctx.restore();

            // Paper grain texture
            const paper = document.createElement('canvas');
            paper.width = width; paper.height = height;
            const pctx = paper.getContext('2d');
            const pData = pctx.createImageData(width, height);
            for (let i = 0; i < pData.data.length; i += 4) {
                const v = 200 + Math.random() * 55;
                pData.data[i] = pData.data[i + 1] = pData.data[i + 2] = v;
                pData.data[i + 3] = 20 + Math.random() * 15;
            }
            pctx.putImageData(pData, 0, 0);
            ctx.save(); ctx.globalCompositeOperation = 'overlay'; ctx.globalAlpha = 0.2;
            ctx.drawImage(paper, 0, 0);
            ctx.restore();

            // Directional bleed (wet-on-wet)
            const bleed = ctx.getImageData(0, 0, width, height);
            const d = bleed.data;
            for (let pass = 0; pass < 2; pass++) {
                for (let i = 0; i < d.length; i += 4) {
                    const ofs = ((rand(0, 5) | 0) * width + (rand(0, 5) | 0)) * 4;
                    if (i + ofs < d.length && i + ofs >= 0) {
                        d[i] = d[i] * 0.7 + d[i + ofs] * 0.3;
                        d[i + 1] = d[i + 1] * 0.7 + d[i + ofs + 1] * 0.3;
                        d[i + 2] = d[i + 2] * 0.7 + d[i + ofs + 2] * 0.3;
                    }
                }
            }
            ctx.putImageData(bleed, 0, 0);

            // Pigment granulation
            ctx.save(); ctx.globalCompositeOperation = 'multiply'; ctx.globalAlpha = 0.15;
            for (let i = 0; i < 2000; i++) {
                const x = rand(0, width); const y = rand(0, height);
                ctx.beginPath(); ctx.arc(x, y, 1 + Math.random() * 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.5})`;
                ctx.fill();
            }
            ctx.restore();

            // Soft brush strokes
            ctx.save(); ctx.globalCompositeOperation = 'multiply'; ctx.globalAlpha = 0.25; ctx.lineCap = 'round';
            for (let s = 0; s < 150; s++) {
                const x0 = rand(0, width), y0 = rand(0, height);
                const dx = rand(-60, 60), dy = rand(-60, 60);
                const px = ctx.getImageData(x0 | 0, y0 | 0, 1, 1).data;
                const [h] = rgbToHSL(px[0], px[1], px[2]);
                ctx.strokeStyle = `hsla(${h},40%,${40 + Math.random() * 20}%,1)`;
                ctx.lineWidth = 2 + Math.random() * 3;
                ctx.beginPath(); ctx.moveTo(x0, y0);
                ctx.bezierCurveTo(
                    x0 + dx * 0.3 + rand(-40, 40), y0 + dy * 0.3 + rand(-40, 40),
                    x0 + dx * 0.7 + rand(-40, 40), y0 + dy * 0.7 + rand(-40, 40),
                    x0 + dx, y0 + dy
                );
                ctx.stroke();
            }
            ctx.restore();
        }

        // 2) Oil Painting Effect
        function applyOilPaintingEffect(ctx, width, height) {
            // Contrast & color boost
            const imgData = ctx.getImageData(0, 0, width, height);
            for (let i = 0; i < imgData.data.length; i += 4) {
                for (let c = 0; c < 3; c++) {
                    imgData.data[i + c] = Math.min(255, Math.max(0, (imgData.data[i + c] - 128) * 1.6 + 128));
                }
            }
            ctx.putImageData(imgData, 0, 0);

            // Impasto canvas texture
            const tex = document.createElement('canvas'); tex.width = width; tex.height = height;
            const tctx = tex.getContext('2d');
            const tData = tctx.createImageData(width, height);
            for (let i = 0; i < tData.data.length; i += 4) {
                const v = 200 + Math.random() * 55;
                tData.data[i] = tData.data[i + 1] = tData.data[i + 2] = v;
                tData.data[i + 3] = 20 + Math.random() * 30;
            }
            tctx.putImageData(tData, 0, 0);
            ctx.save(); ctx.globalCompositeOperation = 'overlay'; ctx.globalAlpha = 0.4;
            ctx.drawImage(tex, 0, 0); ctx.restore();

            // Grayscale & gradient
            const gray = new Float32Array(width * height);
            for (let i = 0, j = 0; i < imgData.data.length; i += 4, j++) gray[j] = imgData.data[i] * 0.299 + imgData.data[i + 1] * 0.587 + imgData.data[i + 2] * 0.114;
            const gradDir = new Float32Array(width * height);
            const kx = [-1, 0, 1, -2, 0, 2, -1, 0, 1], ky = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    for (let wy = -1; wy <= 1; wy++)for (let wx = -1; wx <= 1; wx++) {
                        const v = gray[(y + wy) * width + (x + wx)];
                        const wk = (wy + 1) * 3 + (wx + 1); gx += v * kx[wk]; gy += v * ky[wk];
                    }
                    gradDir[y * width + x] = Math.atan2(gy, gx);
                }
            }

            // Brush strokes along gradient
            ctx.save(); ctx.globalAlpha = 0.6; ctx.lineCap = 'round';
            for (let y = 0; y < height; y += 10) {
                for (let x = 0; x < width; x += 10) {
                    const idx = y * width + x, ang = gradDir[idx] || rand(0, Math.PI * 2), len = rand(8, 16);
                    const px = ctx.getImageData(x, y, 1, 1).data;
                    ctx.strokeStyle = `rgba(${px[0]},${px[1]},${px[2]},0.85)`;
                    ctx.lineWidth = rand(2, 5);
                    const x1 = x - half= x-Math.cos(ang) * len / 2, y1 = y - Math.sin(ang) * len / 2;
                    const x2 = x + Math.cos(ang) * len / 2, y2 = y + Math.sin(ang) * len / 2;
                    ctx.beginPath(); ctx.moveTo(x1 + rand(-3, 3), y1 + rand(-3, 3));
                    ctx.lineTo(x2 + rand(-3, 3), y2 + rand(-3, 3)); ctx.stroke();
                }
            } ctx.restore();

            // Swirl highlights
            ctx.save(); ctx.globalAlpha = 0.15; ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = rand(1, 3);
            for (let i = 0; i < 5; i++) {
                const cx = rand(0, width), cy = rand(0, height), r = rand(20, 100);
                ctx.beginPath(); ctx.arc(cx, cy, r, rand(0, Math.PI), rand(0, Math.PI) + Math.PI * 1.5); ctx.stroke();
            }
            ctx.restore();
        }

        // 3) Sketch Effect
        function applySketchEffect(ctx, width, height) {
            // White base & blur
            ctx.save(); ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, width, height);
            ctx.drawImage(ctx.canvas, 0, 0); ctx.filter = 'blur(1px)'; ctx.drawImage(ctx.canvas, 0, 0);
            ctx.filter = 'none'; ctx.restore();

            // Grayscale
            const src = ctx.getImageData(0, 0, width, height);
            const gray = new Float32Array(width * height);
            for (let i = 0, j = 0; i < src.data.length; i += 4, j++) gray[j] = 0.21 * src.data[i] + 0.72 * src.data[i + 1] + 0.07 * src.data[i + 2];

            // Sobel edges & direction
            const sobel = new Float32Array(width * height), gradDir = new Float32Array(width * height);
            const kx = [-1, 0, 1, -2, 0, 2, -1, 0, 1], ky = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    for (let wy = -1; wy <= 1; wy++)for (let wx = -1; wx <= 1; wx++) {
                        const v = gray[(y + wy) * width + (x + wx)];
                        const wk = (wy + 1) * 3 + (wx + 1); gx += v * kx[wk]; gy += v * ky[wk];
                    }
                    const idx = y * width + x; sobel[idx] = Math.hypot(gx, gy); gradDir[idx] = Math.atan2(gy, gx);
                }
            }

            // Normalize & invert
            let maxG = 0; for (let v of sobel) if (v > maxG) maxG = v;
            const out = ctx.createImageData(width, height);
            for (let i = 0; i < sobel.length; i++) {
                const c = (255 * (1 - (sobel[i] / maxG))) | 0;
                out.data[4 * i] = out.data[4 * i + 1] = out.data[4 * i + 2] = c; out.data[4 * i + 3] = 255;
            }
            ctx.putImageData(out, 0, 0);

            // Hatching
            ctx.save(); ctx.globalCompositeOperation = 'multiply'; ctx.globalAlpha = 0.1; ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.lineCap = 'round';
            for (let i = 0; i < 5000; i++) {
                let x = rand(0, width) | 0, y = rand(0, height) | 0;
                const idx = y * width + x, darkness = 1 - (sobel[idx] / maxG); if (Math.random() > darkness) continue;
                const ang = gradDir[idx] + rand(-0.25, 0.25), len = rand(5, 15);
                const x0 = x - Math.cos(ang) * len / 2, y0 = y - Math.sin(ang) * len / 2;
                const x1 = x + Math.cos(ang) * len / 2, y1 = y + Math.sin(ang) * len / 2;
                ctx.beginPath(); ctx.moveTo(x0 + rand(-2, 2), y0 + rand(-2, 2)); ctx.lineTo(x1 + rand(-2, 2), y1 + rand(-2, 2)); ctx.stroke();
            }
            ctx.restore();

            // Paper texture
            const pcan = document.createElement('canvas'); pcan.width = width; pcan.height = height;
            const pct = pcan.getContext('2d'); const pdat = pct.createImageData(width, height);
            for (let i = 0; i < pdat.data.length; i += 4) {
                const v = 200 + rand(0, 55);
                pdat.data[i] = pdat.data[i + 1] = pdat.data[i + 2] = v; pdat.data[i + 3] = 20 + rand(0, 10);
            } pct.putImageData(pdat, 0, 0);
            ctx.save(); ctx.globalCompositeOperation = 'overlay'; ctx.globalAlpha = 0.2; ctx.drawImage(pcan, 0, 0); ctx.restore();
        }

        // 4) Anime Effect
        function applyAnimeEffect(ctx, width, height) {
            // Offscreen smoothing + quantization + edges
            const off = document.createElement('canvas'); off.width = width; off.height = height;
            const o = off.getContext('2d'); o.drawImage(ctx.canvas, 0, 0);
            o.filter = 'blur(2px)'; o.drawImage(off, 0, 0); o.filter = 'none';
            const img = o.getImageData(0, 0, width, height), d = img.data;
            const levels = 4;
            for (let i = 0; i < d.length; i += 4) { for (let c = 0; c < 3; c++) d[i + c] = Math.floor(d[i + c] / 255 * (levels - 1)) * (255 / (levels - 1)); }
            o.putImageData(img, 0, 0);
            // Sobel
            const gray = new Float32Array(width * height);
            for (let i = 0, j = 0; i < d.length; i += 4, j++) gray[j] = 0.299 * d[i] + 0.587 * d[i + 1] + 0.114 * d[i + 2];
            const sob = new Uint8ClampedArray(width * height), kx = [-1, 0, 1, -2, 0, 2, -1, 0, 1], ky = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    for (let wy = -1; wy <= 1; wy++)for (let wx = -1; wx <= 1; wx++) {
                        const v = gray[(y + wy) * width + (x + wx)]; const idx = (wy + 1) * 3 + (wx + 1);
                        gx += v * kx[idx]; gy += v * ky[idx];
                    }
                    sob[y * width + x] = Math.hypot(gx, gy) > 100 ? 255 : 0;
                }
            }
            // Draw
            ctx.clearRect(0, 0, width, height); ctx.drawImage(off, 0, 0);
            // Outlines
            ctx.save(); ctx.globalCompositeOperation = 'multiply'; ctx.strokeStyle = 'rgba(20,20,20,0.8)'; ctx.lineWidth = 1.5;
            for (let y = 1; y < height - 1; y++)for (let x = 1; x < width - 1; x++) { if (sob[y * width + x]) { ctx.beginPath(); ctx.moveTo(x + 0.5, y + 0.5); ctx.lineTo(x + 0.5, y + 0.5); ctx.stroke(); } }
            ctx.restore();
            // Highlight glow
            ctx.save(); ctx.globalCompositeOperation = 'screen'; ctx.filter = 'blur(4px) brightness(1.2)'; ctx.drawImage(ctx.canvas, 0, 0); ctx.restore(); ctx.filter = 'none';
        }

        // 5) Impressionist Effect
        function applyImpressionistEffect(ctx, width, height) {
            // Base blur & color boost
            ctx.save(); ctx.filter = 'blur(2px) brightness(1.1) saturate(1.15)'; ctx.drawImage(ctx.canvas, 0, 0); ctx.filter = 'none'; ctx.restore();
            // Paper texture
            const paper = document.createElement('canvas'); paper.width = width; paper.height = height;
            const pctx = paper.getContext('2d'); const pData = pctx.createImageData(width, height);
            for (let i = 0; i < pData.data.length; i += 4) { const v = 220 + rand(0, 35); pData.data[i] = pData.data[i + 1] = pData.data[i + 2] = v; pData.data[i + 3] = 15 + rand(0, 15); } pctx.putImageData(pData, 0, 0);
            ctx.save(); ctx.globalCompositeOperation = 'overlay'; ctx.globalAlpha = 0.2; ctx.drawImage(paper, 0, 0); ctx.restore();
            // Dabs
            ctx.save(); ctx.globalAlpha = 0.6;
            for (let i = 0; i < 1500; i++) {
                const x = rand(0, width), y = rand(0, height), px = ctx.getImageData(x | 0, y | 0, 1, 1).data;
                let [h, s, l] = rgbToHSL(px[0], px[1], px[2]); h += rand(-10, 10); s = Math.min(100, s * (0.8 + rand(0, 0.4))); l = Math.min(100, l * (0.8 + rand(0, 0.4)));
                const rx = 2 + rand(0, 4), ry = 2 + rand(0, 4), angle = rand(0, Math.PI * 2);
                ctx.translate(x, y); ctx.rotate(angle); ctx.fillStyle = `hsla(${h},${s}%,${l}%,0.6)`;
                ctx.beginPath(); ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2); ctx.fill(); ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            ctx.restore();
            // Highlights scatter
            ctx.save(); ctx.globalCompositeOperation = 'screen'; ctx.globalAlpha = 0.15;
            for (let i = 0; i < 200; i++) {
                const x = rand(0, width), y = rand(0, height), rad = 10 + rand(0, 30);
                const grad = ctx.createRadialGradient(x, y, 0, x, y, rad); grad.addColorStop(0, 'rgba(255,255,255,0.4)'); grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x, y, rad, 0, Math.PI * 2); ctx.fill();
            }
            ctx.restore();
        }

        // 6) Display Results UI
        function displayResults(originalData, styledData) {
            const loading = document.getElementById('loading');
            const results = document.getElementById('resultsSection');
            loading.style.display = 'none'; results.style.opacity = 0;
            results.style.display = 'block';
            const origImg = document.getElementById('originalImage');
            const styledImg = document.getElementById('styledImage');
            origImg.src = originalData; styledImg.src = styledData;
            origImg.alt = 'Original'; styledImg.alt = 'Styled image';
            const titles = { vangogh: 'Van Gogh Style', watercolor: 'Watercolor Dream', oil: 'Oil Painting', sketch: 'Charcoal Sketch', anime: 'Anime Style', impressionist: 'Impressionist' };
            document.getElementById('styleTitle').innerText = titles[selectedStyle] || 'Artistic Style';
            const quotes = romanticQuotes[selectedStyle] || [];
            if (quotes.length) document.getElementById('romanticText').innerText = quotes[Math.floor(Math.random() * quotes.length)];
            // Fade in
            let fade = 0;
            const fadeIn = setInterval(() => {
                fade += 0.05; results.style.opacity = fade;
                if (fade >= 1) clearInterval(fadeIn);
            }, 30);
            results.scrollIntoView({ behavior: 'smooth' });
        }


        function downloadImage(type) {
            const link = document.createElement('a');
            const imgEl = type === 'original' ?
                document.getElementById('originalImage') :
                document.getElementById('styledImage');

            link.href = imgEl.src;
            link.download = type === 'original' ? 'original.png' : `${selectedStyle}_art.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>

</html>